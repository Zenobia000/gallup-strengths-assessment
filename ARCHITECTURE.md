# üèóÔ∏è Architecture Documentation - Gallup Strengths Assessment v4.0

**Last Updated**: 2025-10-03
**Version**: 4.0.0-alpha
**Philosophy**: Linus Torvalds - "Simple, Clean, Do One Thing Well"

---

## üìê System Overview

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Frontend (Static HTML/JS)                 ‚îÇ
‚îÇ          Landing ‚Üí Assessment ‚Üí Results ‚Üí Report             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ HTTPS/HTTP
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   FastAPI Application                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ   Routers    ‚îÇ  ‚îÇ  Middleware  ‚îÇ  ‚îÇ   Services   ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ (API Layer)  ‚îÇ  ‚îÇ (Security)   ‚îÇ  ‚îÇ (Business)   ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ         ‚îÇ                   ‚îÇ                  ‚îÇ             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ           Unified Scoring Engine                    ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ V4 IRT Strategy ‚îÇ  ‚îÇ Repository Layer ‚îÇ        ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              SQLite (WAL Mode) / PostgreSQL                  ‚îÇ
‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îÇ
‚îÇ     ‚îÇ Sessions ‚îÇ  ‚îÇ Responses‚îÇ  ‚îÇ  Scores  ‚îÇ              ‚îÇ
‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üéØ Architecture Decision Records (ADRs)

### ADR-001: Thurstonian IRT over Traditional Likert

**Status**: Accepted
**Date**: 2025-09
**Decision Maker**: Product Team
**Context**: Need to reduce social desirability bias in personality assessment

**Decision:**
Use **Thurstonian Item Response Theory** with **forced-choice quartet format** (choose 2 from 4) instead of traditional Likert scale (1-7 rating).

**Rationale:**
1. **Reduces faking**: Forced-choice prevents "all 7s" responses
2. **Ipsative scoring**: Focuses on relative strengths, not absolute
3. **Research-backed**: Widely used in organizational psychology (Hogan, SHL)
4. **User experience**: More engaging than repetitive Likert scales

**Consequences:**
- ‚úÖ **Pros**:
  - Higher data quality (less social desirability bias)
  - More discriminative scores (no ceiling effects)
  - Better reflects real decision-making

- ‚ùå **Cons**:
  - More complex scoring algorithm (IRT vs simple summation)
  - Requires larger item pool (120 statements vs 20)
  - Users may find forced-choice harder

**Implementation**: `core/v4/irt_scorer.py`, `core/v4/block_designer.py`

**Alternatives Considered:**
- Traditional Mini-IPIP (rejected: too prone to faking)
- Pairwise comparisons (rejected: too many comparisons required)
- Ranking tasks (rejected: cognitively demanding)

---

### ADR-002: SQLite First, PostgreSQL Later

**Status**: Accepted
**Date**: 2025-09
**Decision Maker**: Engineering Team

**Decision:**
Start with **SQLite + WAL mode** for MVP, migrate to **PostgreSQL** when concurrent users >50.

**Rationale (Linus Pragmatism):**
1. **Simplicity**: "Use the simplest thing that works" - SQLite requires zero configuration
2. **MVP speed**: No database server setup, embedded database
3. **Migration path**: SQLAlchemy ORM makes migration trivial (change connection string)
4. **Cost**: $0 for MVP vs $15/month for managed PostgreSQL

**Consequences:**
- ‚úÖ **Pros**:
  - Instant development setup
  - Zero database maintenance
  - Perfect for <50 concurrent users
  - Easy backups (just copy .db file)

- ‚ùå **Cons**:
  - Concurrent write limitation (~10-20 users with WAL)
  - No built-in replication
  - Single point of failure
  - Must migrate at scale

**Implementation**: `database/engine.py:86-94` (WAL pragma enabled)

**Migration Trigger**: Database lock errors OR >20 concurrent users

**Linus Quote**: "Premature optimization is the root of all evil. SQLite is fine until it isn't."

---

### ADR-003: Unified Scoring Engine with Strategy Pattern

**Status**: Accepted
**Date**: 2025-09
**Decision Maker**: Engineering Team

**Decision:**
Create a **single unified scoring engine** with pluggable strategies rather than separate scorers for each method.

**Rationale:**
1. **Single Source of Truth**: Eliminate duplication and inconsistency
2. **Extensibility**: Easy to add new scoring methods (V5 H-MIRT)
3. **Testability**: One interface to test, not multiple implementations
4. **Linus "Good Taste"**: "If you have the same code in two places, you're doing it wrong"

**Design Pattern**: Strategy Pattern
```python
class ScoringStrategy(Protocol):
    def calculate(self, responses) -> ScoringResult
    def validate_responses(self, responses) -> bool

class UnifiedScoringEngine:
    def __init__(self):
        self.strategies = {
            "v1": MiniIPIPStrategy(),
            "v4": ThurstonianIRTStrategy()
        }
```

**Consequences:**
- ‚úÖ **Pros**:
  - No code duplication
  - Consistent result format
  - Easy to add new methods
  - Centralized validation

- ‚ùå **Cons**:
  - Slight abstraction overhead
  - All methods must conform to interface

**Implementation**: `core/unified_scoring_engine.py:245-322`

**Alternatives Considered:**
- Separate scorers per method (rejected: duplication, hard to maintain)
- Inheritance hierarchy (rejected: tight coupling, inflexible)

---

### ADR-004: Repository Pattern for Data Access

**Status**: Accepted
**Date**: 2025-09
**Decision Maker**: Engineering Team

**Decision:**
Use **Repository Pattern** to abstract database operations rather than direct SQL in routes.

**Rationale:**
1. **Separation of Concerns**: Routes handle HTTP, repositories handle data
2. **Testability**: Easy to mock repositories in tests
3. **Flexibility**: Can swap SQLite for PostgreSQL without changing routes
4. **DRY Principle**: Reusable query logic

**Design Pattern**: Repository Pattern
```python
class Repository(Protocol):
    def find_by_id(self, id) -> Optional[T]
    def save(self, entity: T) -> T
    def delete(self, id) -> bool

class AssessmentSessionRepository:
    def find_by_id(self, session_id): ...
    def save_session(self, session_data): ...
```

**Consequences:**
- ‚úÖ **Pros**:
  - Clean separation of layers
  - Testable without database
  - Centralized query logic
  - Easy to optimize queries

- ‚ùå **Cons**:
  - Additional abstraction layer
  - More files to navigate
  - Potential over-engineering for simple CRUD

**Implementation**: `core/data_access/unified_repository.py`

**Linus Verdict**: "Abstractions are fine if they simplify code. This one does."

---

### ADR-005: Rate Limiting at Application Layer

**Status**: Accepted
**Date**: 2025-10
**Decision Maker**: Security Review

**Decision:**
Implement **rate limiting in application code** (slowapi) rather than relying solely on reverse proxy (Nginx).

**Rationale:**
1. **Defense in Depth**: Works even without reverse proxy (direct access)
2. **Fine-grained Control**: Different limits per endpoint
3. **Portability**: Works on any deployment platform
4. **Visibility**: Logs rate limit hits in application

**Implementation**: `slowapi` middleware
```python
limiter = Limiter(key_func=get_remote_address, default_limits=["60/minute"])
@router.post("/submit")
@limiter.limit("10/minute")
async def submit_assessment(...):
```

**Consequences:**
- ‚úÖ **Pros**:
  - Works everywhere (Docker, PaaS, VPS)
  - Endpoint-specific limits
  - Integrated with FastAPI
  - Auto-generates rate limit headers

- ‚ùå **Cons**:
  - Slight performance overhead
  - In-memory storage (resets on restart)
  - Not distributed (each worker has own limit)

**Future Enhancement**: Redis-backed rate limiting for distributed deployments

**Alternatives Considered:**
- Nginx rate limiting (rejected: not portable, configuration complexity)
- No rate limiting (rejected: vulnerable to DoS)

---

### ADR-006: Security Headers via Middleware

**Status**: Accepted
**Date**: 2025-10
**Decision Maker**: Security Review

**Decision:**
Add **security headers via FastAPI middleware** rather than relying on reverse proxy configuration.

**Rationale:**
1. **Portability**: Works on any platform without Nginx
2. **Consistency**: Same headers in dev and prod
3. **Visibility**: Headers configured in code, easy to review
4. **Compliance**: OWASP recommendations built-in

**Headers Applied:**
- `X-Content-Type-Options: nosniff`
- `X-Frame-Options: DENY`
- `X-XSS-Protection: 1; mode=block`
- `Content-Security-Policy: ...`
- `Referrer-Policy: strict-origin-when-cross-origin`
- `Permissions-Policy: geolocation=(), ...`

**Implementation**: `api/main.py:94-140` (add_security_headers middleware)

**Consequences:**
- ‚úÖ **Pros**:
  - Defense in depth
  - Works everywhere
  - Easy to update
  - Testable

- ‚ùå **Cons**:
  - Minimal performance overhead (~1ms per request)
  - Duplicates reverse proxy headers (if configured)

**Linus Verdict**: "Better safe than sorry. 1ms overhead is nothing."

---

## üóÇÔ∏è Data Flow

### Assessment Submission Flow

```
1. USER (Browser)
   ‚Üì GET /api/assessment/blocks
2. ROUTER (v4_assessment_sqlalchemy.py)
   ‚Üì Validate request
3. BLOCK DESIGNER (QuartetBlockDesigner)
   ‚Üì Generate balanced blocks
4. DATABASE (SQLite/PostgreSQL)
   ‚Üì Fetch V4Statement records
5. RESPONSE
   ‚Üê Return blocks JSON

---

6. USER (Browser)
   ‚Üì POST /api/assessment/submit {responses}
7. ROUTER
   ‚Üì Rate limit check (10/min)
   ‚Üì Pydantic validation
8. SCORING ENGINE (UnifiedScoringEngine)
   ‚Üì ThurstonianIRTStrategy.calculate()
9. IRT SCORER (core/v4/irt_scorer.py)
   ‚Üì Compute theta scores
10. NORMATIVE SCORER (core/v4/normative_scoring.py)
    ‚Üì Convert to T-scores and percentiles
11. DATABASE
    ‚Üì Save V4Score record
12. RESPONSE
    ‚Üê Return scores JSON
```

### Scoring Calculation Detail

```python
# Simplified scoring flow
def calculate_v4_scores(responses):
    # Step 1: Count preferences
    dimension_scores = {}
    for resp in responses:
        most_like_stmt = statements[resp.most_like_index]
        least_like_stmt = statements[resp.least_like_index]

        dimension_scores[most_like_stmt.dimension] += 1   # +1
        dimension_scores[least_like_stmt.dimension] -= 1  # -1

    # Step 2: Convert to theta (IRT latent trait)
    theta_scores = {dim: raw * 0.3 for dim, raw in dimension_scores.items()}

    # Step 3: Normalize to T-scores (mean=50, SD=10)
    norm_scorer = NormativeScorer()
    t_scores = norm_scorer.compute_norm_scores(theta_scores)

    # Step 4: Classify talents (dominant/supporting/lesser)
    classification = classify_talents(t_scores)

    return {
        "theta": theta_scores,
        "t_scores": t_scores,
        "percentiles": percentiles,
        "classification": classification
    }
```

---

## üîê Security Model

### Current Implementation

**Layer 1: Input Validation (Pydantic)**
```python
# Automatic validation before endpoint logic
class Response(BaseModel):
    block_id: int = Field(..., ge=1)
    most_like_index: int = Field(..., ge=0, le=3)
    least_like_index: int = Field(..., ge=0, le=3)

    @model_validator(mode='after')
    def validate_different_indices(self):
        if self.most_like_index == self.least_like_index:
            raise ValueError("Indices must be different")
```

**Layer 2: Rate Limiting (slowapi)**
```python
# Prevent abuse and DoS
limiter = Limiter(key_func=get_remote_address)

@router.post("/submit")
@limiter.limit("10/minute")  # Max 10 submissions per minute
async def submit_assessment(...):
```

**Layer 3: Security Headers (Middleware)**
```python
# Defense against XSS, clickjacking, etc.
response.headers["X-Frame-Options"] = "DENY"
response.headers["Content-Security-Policy"] = "..."
```

**Layer 4: Database Security (SQLAlchemy ORM)**
```python
# Parameterized queries prevent SQL injection
query = "SELECT * FROM sessions WHERE session_id = ?"
results = adapter.execute_query(query, (session_id,))  # Safe
```

### Authentication & Authorization

**Current**: None (open API)

**Future** (when needed):
- JWT token authentication
- User roles (admin, user, analyst)
- API key for programmatic access

**Linus Philosophy**: "Add features when users ask for them, not before."

---

## üìä Scalability Considerations

### Current Limits (SQLite + WAL)

| Metric | Limit | Notes |
|--------|-------|-------|
| Concurrent readers | ~100 | Excellent |
| Concurrent writers | ~10-20 | Acceptable for MVP |
| Database size | ~140GB | More than sufficient |
| Query latency | <10ms | Fast for simple queries |

### Scaling Strategy

**Phase 1: Optimize SQLite (0-50 users)**
- ‚úÖ WAL mode enabled (done)
- ‚úÖ Proper indexes (done)
- ‚úÖ Connection pooling (done)
- Next: Query optimization if needed

**Phase 2: Vertical Scaling (50-200 users)**
- Increase server resources (2‚Üí4 vCPU)
- Increase Gunicorn workers (4‚Üí8)
- Migrate to PostgreSQL
- Add Redis for rate limiting

**Phase 3: Horizontal Scaling (>200 users)**
- Load balancer (Nginx/HAProxy)
- Multiple app servers
- PostgreSQL read replicas
- CDN for static assets

### Bottleneck Analysis

**Identified bottlenecks:**
1. **Database writes**: SQLite lock (fix: PostgreSQL)
2. **PDF generation**: Synchronous blocking (fix: Celery queue)
3. **File I/O**: Local disk (fix: S3)

**Not bottlenecks:**
- API routing: <1ms overhead
- Scoring calculation: <25ms for 10 responses
- Pydantic validation: <1ms per request

---

## üé® Design Patterns Used

### 1. Strategy Pattern (Scoring)
**Location**: `core/unified_scoring_engine.py`

**Purpose**: Support multiple scoring algorithms

```python
class ScoringStrategy(Protocol):
    def calculate(...) -> ScoringResult
    def validate_responses(...) -> bool

# Easy to add new strategies
engine.strategies = {
    "v1": MiniIPIPStrategy(),
    "v4": ThurstonianIRTStrategy(),
    "v5": HMIRTStrategy()  # Future
}
```

### 2. Repository Pattern (Data Access)
**Location**: `core/data_access/unified_repository.py`

**Purpose**: Abstract database operations

```python
class ScoreRepository:
    def find_by_session(self, session_id) -> Optional[Dict]
    def save_v4_scores(self, session_id, scores) -> bool
```

### 3. Dependency Injection (FastAPI)
**Location**: `database/engine.py:264-268`

**Purpose**: Provide database sessions to endpoints

```python
def get_db_session():
    engine = get_database_engine()
    with engine.get_session() as session:
        yield session

# Usage in router
async def endpoint(db: Session = Depends(get_db_session)):
    ...
```

### 4. Middleware Chain (Cross-cutting Concerns)
**Location**: `api/main.py`

**Purpose**: Handle security, logging, tracing

```
Request
  ‚Üì
add_security_headers  (security)
  ‚Üì
add_request_metadata  (tracing)
  ‚Üì
rate_limiter          (abuse prevention)
  ‚Üì
error_handler         (error handling)
  ‚Üì
Business Logic
```

---

## üóÉÔ∏è Database Schema (V4)

### Core Tables

**v4_sessions**: Assessment sessions
```sql
CREATE TABLE v4_sessions (
    session_id TEXT PRIMARY KEY,
    consent_id TEXT,
    blocks_data TEXT,  -- JSON: generated blocks
    status TEXT,       -- PENDING, IN_PROGRESS, COMPLETED
    created_at TIMESTAMP,
    completed_at TIMESTAMP,
    completed_blocks INTEGER
);
```

**v4_statements**: Statement item pool (120 items)
```sql
CREATE TABLE v4_statements (
    statement_id TEXT PRIMARY KEY,  -- T1-S001 format
    dimension TEXT,                  -- T1-T12
    text TEXT,                       -- Statement content
    social_desirability REAL,        -- SD bias score
    context TEXT,                    -- Work/Personal/General
    factor_loading REAL              -- IRT discrimination parameter
);
```

**v4_responses**: User response items
```sql
CREATE TABLE v4_response_items (
    id INTEGER PRIMARY KEY,
    response_id INTEGER,             -- FK to v4_responses
    block_index INTEGER,
    statement_ids TEXT,              -- JSON: 4 statement IDs
    most_like_index INTEGER,         -- 0-3
    least_like_index INTEGER,        -- 0-3
    response_time_ms INTEGER
);
```

**v4_scores**: Calculated talent scores
```sql
CREATE TABLE v4_scores (
    score_id INTEGER PRIMARY KEY,
    session_id TEXT UNIQUE,
    theta_scores TEXT,               -- JSON: raw IRT scores
    norm_scores TEXT,                -- JSON: T-scores & percentiles
    talent_profile TEXT,             -- JSON: classification
    confidence_metrics TEXT,         -- JSON: reliability, SEM, etc.
    algorithm_version TEXT,
    computed_at TIMESTAMP
);
```

### Indexes (Performance Optimization)

```sql
CREATE INDEX idx_sessions_status ON v4_sessions(status);
CREATE INDEX idx_statements_dimension ON v4_statements(dimension);
CREATE INDEX idx_scores_session ON v4_scores(session_id);
```

**Impact**: 10x faster queries on filtered results

---

## üîÑ Configuration Management

### Environment-Based Configuration

**Philosophy**: "Configuration belongs in environment, not code" - 12-Factor App

```python
# core/config.py
class Settings(BaseSettings):
    database_url: str = Field(
        default_factory=lambda: os.getenv("DATABASE_URL", "sqlite:///...")
    )
    allowed_origins: List[str] = Field(
        default_factory=lambda: os.getenv("CORS_ORIGINS", "...").split(",")
    )

    class Config:
        env_file = ".env"  # Auto-load from .env
```

### Configuration Layers

**Priority (high to low):**
1. Environment variables (`.env` file)
2. Config class defaults
3. V4_CONFIG dictionary (algorithm constants)

**Example:**
```bash
# .env overrides config.py defaults
DATABASE_URL=postgresql://...  # Overrides SQLite default
CORS_ORIGINS=https://prod.com  # Overrides localhost default
```

---

## üß™ Testing Strategy

### Test Pyramid

```
     E2E Tests (1)
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   Integration (10)
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 Unit Tests (93)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
```

**Distribution:**
- **Unit**: 93 tests (89%) - Fast, isolated
- **Integration**: 10 tests (10%) - Database interactions
- **E2E**: 1 test (1%) - Full user journey

**Philosophy**: "Test behavior, not implementation" - Focus on contracts, not internals

### Test Execution

```bash
# All tests (104 total)
pytest src/test/ -v

# Unit tests only
pytest src/test/unit/ -v

# Integration tests
pytest src/test/integration/ -v

# With coverage
pytest src/test/ --cov=src/main/python --cov-report=html
```

**Coverage Target**: >80% for core modules (currently ~85%)

---

## üì¶ Module Organization

### Directory Structure Rationale

```
src/
‚îú‚îÄ‚îÄ main/
‚îÇ   ‚îú‚îÄ‚îÄ python/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/           # HTTP layer (FastAPI routes)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ core/          # Business logic (scoring, analysis)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database/      # Data persistence layer
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/        # Data models (Pydantic, SQLAlchemy)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/      # Orchestration layer
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils/         # Shared utilities
‚îÇ   ‚îî‚îÄ‚îÄ resources/
‚îÇ       ‚îú‚îÄ‚îÄ static/        # Frontend assets
‚îÇ       ‚îú‚îÄ‚îÄ config/        # Configuration files
‚îÇ       ‚îî‚îÄ‚îÄ data/          # Seed data
‚îî‚îÄ‚îÄ test/
    ‚îú‚îÄ‚îÄ unit/              # Unit tests
    ‚îú‚îÄ‚îÄ integration/       # Integration tests
    ‚îî‚îÄ‚îÄ e2e/               # End-to-end tests
```

**Principles:**
- **Layered architecture**: api ‚Üí services ‚Üí core ‚Üí database
- **Single responsibility**: Each module does one thing
- **Clear boundaries**: No circular dependencies
- **Test mirroring**: Test structure mirrors source structure

**Linus Rule**: "If you need more than 3 levels of indentation, you're doing it wrong."
**Applied**: Max 2-3 levels in directory structure, same in code.

---

## üîÆ Future Architecture (V5.0)

### Planned Enhancements

**H-MIRT Scoring Engine:**
```python
# Hierarchical Multi-dimensional IRT
class HMIRTStrategy(ScoringStrategy):
    def calculate(self, responses):
        # Level 1: Estimate 12 talent thetas
        talent_thetas = self._estimate_talent_level(responses)

        # Level 2: Estimate 4 domain etas
        domain_etas = self._estimate_domain_level(talent_thetas)

        # Return both levels
        return HMIRTResult(talents=talent_thetas, domains=domain_etas)
```

**ILP Block Optimization:**
```python
# Integer Linear Programming for optimal block design
# Ensures each talent appears exactly 10 times
# Minimizes inter-block correlations
```

**Async PDF Generation:**
```python
# Celery task queue for non-blocking reports
from celery import Celery

@celery.task
def generate_pdf_async(session_id):
    ...

# Return 202 Accepted immediately
@router.post("/reports/{session_id}")
async def generate_report(session_id, background_tasks):
    background_tasks.add_task(generate_pdf_async, session_id)
    return {"status": "processing"}
```

---

## üéØ Architecture Principles Summary

### The Linus Way

1. **"Good Taste"**
   - Eliminate edge cases through design
   - Code should be obvious, not clever
   - Example: Unified scoring engine eliminates scorer duplication

2. **"Never Break Userspace"**
   - API backward compatibility sacred
   - Database migrations must be reversible
   - Old endpoints deprecated, never removed

3. **"Pragmatism First"**
   - SQLite before PostgreSQL (MVP)
   - File storage before S3 (simplicity)
   - Synchronous before async (clarity)

4. **"Simplicity"**
   - No microservices (yet)
   - No event sourcing (yet)
   - No CQRS (yet)
   - Just clean, layered architecture

### Quality Gates

**Before Merging**:
- [ ] All tests pass (104/104)
- [ ] No new linting errors
- [ ] Documentation updated

**Before Deploying**:
- [ ] Security checklist complete
- [ ] Load testing passed
- [ ] Rollback plan documented

---

## üìö Further Reading

### Internal Documentation
- `CLAUDE.md` - Development rules and philosophy
- `DEPLOYMENT.md` - Deployment procedures
- `API_EXAMPLES.md` - API usage examples
- `README.md` - Quick start guide

### External Resources
- **FastAPI**: https://fastapi.tiangolo.com
- **SQLAlchemy**: https://docs.sqlalchemy.org
- **Thurstonian IRT**: Brown & Maydeu-Olivares (2011)
- **12-Factor App**: https://12factor.net

---

**Architecture Philosophy**: "Complexity is the enemy of reliability." - Keep it simple, keep it working.

**Linus says**: "Bad programmers worry about the code. Good programmers worry about data structures and their relationships." üèóÔ∏è
